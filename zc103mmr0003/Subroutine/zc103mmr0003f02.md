```abap
*----------------------------------------------------------------------*
***INCLUDE ZC103MMR0003F02.
*----------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*& Form count_stlo_num
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM count_stlo_num .
  " 저장위치 기준으로 입고 미입고 건수를 가져오는 서브루틴
  DATA : lv_from     TYPE sy-datum,        " 시작일 데이터 ex) '20250101'
         lv_to       TYPE sy-datum,        " 종료일 데이터 ex) '20250131'
         lv_index    TYPE n LENGTH 2,
         lt_stlotree LIKE TABLE OF gs_stlotree,
         ls_stlotree LIKE gs_stlotree,
         lv_stlocnt  TYPE i. " 저장위치 수 카운트

  " 1년치 데이터 한번에 가져옴
  lv_from = pa_year && '0101'.
  lv_to = pa_year && '1231'.

  " CDS 뷰에서 개수 미리 세옴
  SELECT FROM zc103mmcds_e_0004( start_date = @lv_from, end_date = @lv_to )
    FIELDS Plnid AS plnid, Pname AS pname, Address AS address, Strid AS strid,
           Sname AS sname, Received AS received, Not_received AS not_received
    INTO TABLE @lt_stlotree.

  " CDS 뷰에서 Received와 Not_received가 다른 행에 나오므로 임시로 collect 하는 코드 추가함
  CLEAR : gt_stlotree.
  LOOP AT lt_stlotree INTO gs_stlotree.

    COLLECT gs_stlotree INTO gt_stlotree.

  ENDLOOP.

  " 입고/미입고 정보가 없는 저장위치는 0, 0으로 세팅한 데이터를 넣는다
  CLEAR : gs_plant, gs_stlotree.
  LOOP AT gt_plant INTO gs_plant.

    CLEAR gs_stlo.

    LOOP AT gt_stlo INTO gs_stlo WHERE plnid EQ gs_plant-plnid.

      " 저장위치 별 입고 미입고 데이터가 있는 지 확인
      ls_stlotree = VALUE #( gt_stlotree[ plnid = gs_stlo-plnid
                                          strid = gs_stlo-strid ] OPTIONAL ).

      IF ls_stlotree IS NOT INITIAL.
        CLEAR ls_stlotree.
        CONTINUE.
      ENDIF.

      " 정보 생성
      gs_stlotree = VALUE #( plnid = gs_plant-plnid
                             pname = gs_plant-name
                             address = gs_plant-address
                             strid = gs_stlo-strid
                             sname = gs_stlo-name
                             received = 0 not_received = 0 ).

      " 테이블에 추가
      APPEND gs_stlotree TO gt_stlotree.
      CLEAR gs_stlotree.

    ENDLOOP.

  ENDLOOP.

  " 플랜트, 저장위치 순서로 정렬
  SORT gt_stlotree BY plnid strid.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form display_stlo_tree_screen
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM display_stlo_tree_screen .

  IF go_stlo_cont IS NOT BOUND.

    PERFORM init_stlo_tree. " 객체 생성
    PERFORM define_stlo_hierarchy_header CHANGING gs_stlo_hierhdr.
    PERFORM build_stlo_comment USING gt_stlo_list_commentary gv_logo.
    PERFORM define_stlo_field_catalog.
    PERFORM create_stlo_hierarchy.
    PERFORM fill_stlo_column_tree.

  ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form init_stlo_tree
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM init_stlo_tree .

  CREATE OBJECT go_stlo_cont
    EXPORTING
      container_name = 'STLO_CONT'.

  CREATE OBJECT go_stlo_tree
    EXPORTING
      parent              = go_stlo_cont
      node_selection_mode = cl_gui_column_tree=>node_sel_mode_single
      item_selection      = ' '.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form define_stlo_hierarchy_header
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*&      <-- GS_STLO_HIERHDR
*&---------------------------------------------------------------------*
FORM define_stlo_hierarchy_header  CHANGING ps_stlo_hierhdr TYPE treev_hhdr.

  ps_stlo_hierhdr = VALUE #( heading = '플랜트명'
                             tooltip = '플랜트명'
                             width = 30 width_pix = space ).

ENDFORM.
*&---------------------------------------------------------------------*
*& Form build_stlo_comment
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*&      --> GT_STLO_LIST_COMMENTARY
*&      --> GV_LOGO
*&---------------------------------------------------------------------*
FORM build_stlo_comment  USING    pt_stlo_list_commentary TYPE slis_t_listheader
                                  pv_logo                 TYPE sdydo_value.

  " 트리 상단
  pt_stlo_list_commentary = VALUE #(
    ( typ = 'H' info = '저장위치 기준' )
    ( typ = 'S' key = '조회년도 : ' info = pa_year )
    ( typ = 'S' key = '오늘날짜 : ' info = sy-datum )
    ( typ = 'S' key = '현재시간 : ' info = sy-uzeit ) ).

  pv_logo = 'SLOGO1'.
  gs_stlo_variant = sy-repid.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form define_stlo_field_catalog
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM define_stlo_field_catalog .

  gt_stlo_fcat = VALUE #(
    ( fieldname = 'PNAME' coltext = '플랜트명' no_out = abap_true )
    ( fieldname = 'SNAME' coltext = '저장위치명' outputlen = 17 )
    ( fieldname = 'ADDRESS' coltext = '플랜트위치' outputlen = 35 )
    ( fieldname = 'RECEIVED' coltext = '입고건수' outputlen = 15 )
    ( fieldname = 'NOT_RECEIVED' coltext = '미입고건수' outputlen = 15 )
  ).

ENDFORM.
*&---------------------------------------------------------------------*
*& Form create_stlo_hierarchy
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM create_stlo_hierarchy .

  " 저장위치 트리

  CALL METHOD go_stlo_tree->set_table_for_first_display
    EXPORTING
      is_variant          = gs_stlo_variant
      i_save              = 'A'
      i_default           = 'X'
      is_hierarchy_header = gs_stlo_hierhdr
      it_list_commentary  = gt_stlo_list_commentary
      i_logo              = gv_logo
      i_background_id     = 'SBACK1'
    CHANGING
      it_outtab           = gt_emsthdtr
      it_fieldcatalog     = gt_stlo_fcat.

  " 이벤트 핸들러 세팅 및 등록
  SET HANDLER : lcl_event_handler=>on_item_ctx_menu_request  FOR go_receipt_tree,
                lcl_event_handler=>on_item_ctx_menu_selected FOR go_receipt_tree,
                lcl_event_handler=>on_node_double_click      FOR go_stlo_tree.

  CALL METHOD go_stlo_tree->get_registered_events
    IMPORTING
      events = gt_stlo_events.

  " node double click 이벤트
  gs_stlo_events-eventid = cl_gui_column_tree=>eventid_node_double_click.
  gs_stlo_events-appl_event = abap_true.
  APPEND gs_stlo_events TO gt_stlo_events.

  CALL METHOD go_stlo_tree->set_registered_events
    EXPORTING
      events = gt_stlo_events.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form fill_stlo_column_tree
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM fill_stlo_column_tree .

  " 저장위치 ALV 트리에 정보를 넣는다
  DATA: lv_node_text   TYPE lvc_value,  " 셀 값
        lv_plnid_key   TYPE lvc_nkey,   " 노드 키 설정
        lv_root_key    TYPE lvc_nkey,   " 루트 (plnid)
        lv_partner_key TYPE lvc_nkey,   "
        lt_layout_item TYPE lvc_t_layi,
        ls_layout      TYPE lvc_s_layn,
        lv_strid_key   TYPE lvc_nkey,
        lv_new_str_key TYPE lvc_nkey,
        lt_plnttree    LIKE TABLE OF gs_stlotree, " 플랜트 노드
        ls_plnttree    LIKE gs_stlotree,
        lt_stlotree    LIKE TABLE OF gs_stlotree. " 스토리지 노드

  " 입고 개수를 합산하는 용도
  DATA : lv_received TYPE i,
         lv_not_rece TYPE i,
         lv_index    TYPE sy-tabix,
         lv_tabix    TYPE sy-tabix,
         lv_node     TYPE i VALUE 1.

  SORT gt_stlotree BY plnid strid.

  lt_plnttree = CORRESPONDING #( gt_stlotree ).
  DELETE ADJACENT DUPLICATES FROM lt_plnttree COMPARING plnid.

  " 플랜트별로 하나만 들기 위해 (스토리지로케이션별로 합산함)
  LOOP AT lt_plnttree INTO DATA(ls_rootnode).

    lv_index = sy-tabix.

    CLEAR : lv_received, lv_not_rece.

    " 테이블 읽어서 같은 플랜트 내의 데이터를 합산한다
    LOOP AT gt_stlotree INTO DATA(ls_subnode) WHERE plnid EQ ls_rootnode-plnid.

      lv_received += ls_subnode-received.
      lv_not_rece += ls_subnode-not_received.

    ENDLOOP.

    ls_plnttree = VALUE #( BASE ls_plnttree
                           strid = '' sname = ''
                           received = lv_received
                           not_received = lv_not_rece ).

    MODIFY lt_plnttree FROM ls_plnttree INDEX lv_index TRANSPORTING strid sname received not_received.

  ENDLOOP.

  SORT lt_plnttree BY plnid.
  CLEAR lv_index.

  LOOP AT lt_plnttree INTO gs_stlotree.

    lv_index = sy-tabix.

    " 상위노드
    CLEAR ls_layout.
    ls_layout = VALUE #( isfolder = abap_true
                         n_image = icon_locked
                         exp_image = icon_unlocked
                         expander = abap_true ).
    lv_node_text = gs_stlotree-pname.

    CALL METHOD go_stlo_tree->add_node
      EXPORTING
        i_relat_node_key = lv_root_key
        i_relationship   = cl_gui_column_tree=>relat_last_child
        is_node_layout   = ls_layout
        i_node_text      = lv_node_text
        is_outtab_line   = gs_stlotree
      IMPORTING
        e_new_node_key   = lv_plnid_key.

    APPEND gs_stlotree TO gt_sttrindx.

    ON CHANGE OF gs_stlotree-plnid.

      LOOP AT gt_stlotree INTO DATA(ls_stlotree) WHERE plnid EQ gs_stlotree-plnid.

        lv_tabix = sy-tabix.

        " 하위노드
        lv_node_text = ls_stlotree-pname.
        CALL METHOD go_stlo_tree->add_node
          EXPORTING
            i_relat_node_key = lv_plnid_key
            i_relationship   = cl_gui_column_tree=>relat_last_child
            i_node_text      = lv_node_text
            is_outtab_line   = ls_stlotree
          IMPORTING
            e_new_node_key   = lv_new_str_key.

        APPEND ls_stlotree TO gt_sttrindx.

      ENDLOOP.

    ENDON.

  ENDLOOP.

  CALL METHOD : go_stlo_tree->update_calculations,
                go_stlo_tree->frontend_update,
                cl_gui_cfw=>flush.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form node_double_click_receipt
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*&      --> PV_NODEKEY
*&---------------------------------------------------------------------*
FORM node_double_click_receipt  USING    pv_nodekey.

  " 월을 기준으로 우측의 구매오더 ALV를 필터링하는 트리 이벤트

  " 입고일 기준
  CLEAR gt_pohd. " alv에 사용되는 itab

  DATA : lv_from     TYPE sy-datum, " 시작 일
         lv_to       TYPE sy-datum, " 종료 일
         lv_month    TYPE n LENGTH 2, " 월
         lv_cnt      TYPE i,        " 필터링 한 구매오더 수
         lv_text(32).  " 구매오더그리드 텍스트

  " 월 문자 생성 (01월 ~ 12월)
  IF pv_nodekey > 10.
    lv_month = pv_nodekey.
  ELSE.
    lv_month = |0{ pv_nodekey }|.
  ENDIF.
  lv_from = pa_year && lv_month && '01'.

  CALL FUNCTION 'RP_LAST_DAY_OF_MONTHS'
    EXPORTING
      day_in            = lv_from
    IMPORTING
      last_day_of_month = lv_to.

  " 출력할 데이터 필터링 ( ex : 20250101 ~ 20250131 )
  gt_pohd = VALUE #( FOR ls_pohd IN gt_pohdback
                       WHERE ( order_date BETWEEN lv_from AND lv_to ) ( ls_pohd ) ).

  lv_cnt = lines( gt_pohd ).
  MESSAGE s008 WITH lv_cnt.

  " 구매오더 텍스트정보
  lv_text = |구매오더정보 : { lv_month }월|.
  gs_po_layo = VALUE #( BASE gs_po_layo
                        grid_title = lv_text ).
  go_po_grid->set_frontend_layout( EXPORTING is_layout = gs_po_layo ).

  " alv refresh
  PERFORM set_data.  " 출력할 alv의 텍스트데이터 설정
  PERFORM refresh_grid USING go_po_grid.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form node_double_click_stlo
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*&      --> PV_NODE_KEY
*&---------------------------------------------------------------------*
FORM node_double_click_stlo  USING    pv_node_key.

  " 구매오더에 설정된 저장위치를 기준으로 구매오더 필터링
  " 플랜트 선택시 해당 플랜트의 모든 구매오더 조회
  " 저장위치 선택시 해당 저장위치에만 해당하는 구매오더 조회

  DATA : lv_cnt      TYPE i,
         lv_text(32).

  " 저장위치 별로 노드 파싱
  CLEAR gt_pohd. " alv에 사용되는 itab
  READ TABLE gt_sttrindx INTO gs_stlotree INDEX pv_node_key.

  IF gs_stlotree-strid IS INITIAL. " 루트 키 (플랜트) 선택
    " 플랜트 키가 같은 것만 alv에 보여준다
    gt_pohd = VALUE #( FOR ls_pohd IN gt_pohdback
                         WHERE ( plnid EQ gs_stlotree-plnid ) ( ls_pohd ) ).

    lv_text = |구매오더정보 : { gs_stlotree-pname }|.

  ELSE. " 저장위치 선택
    " 스토리지 위치까지 같은 것만 alv에 보여준다.
    gt_pohd = VALUE #( FOR ls_pohd IN gt_pohdback
                         WHERE ( plnid EQ gs_stlotree-plnid AND
                                 strid EQ gs_stlotree-strid ) ( ls_pohd ) ).

    lv_text = |구매오더정보 : { gs_stlotree-pname } - { gs_stlotree-sname }|.

  ENDIF.

  lv_cnt = lines( gt_pohd ).
  MESSAGE s008 WITH lv_cnt.

  " 구매오더정보 텍스트 세팅
  gs_po_layo = VALUE #( BASE gs_po_layo
                        grid_title = lv_text ).
  go_po_grid->set_frontend_layout( EXPORTING is_layout = gs_po_layo ).

  " ALV 새로고침
  PERFORM set_data.
  PERFORM refresh_grid USING go_po_grid.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form set_gr_fcat
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM set_gr_fcat .

  gt_gr_fcat = VALUE #(
      ( key = abap_true fieldname = 'STATUS' just = 'C' coltext = '상태'  emphasize = abap_true )
    ( key = abap_true fieldname = 'GRID' ref_table = 'ZC103MMT0013' just = 'C' hotspot = abap_true  )
    ( fieldname = 'POID' ref_table = 'ZC103MMT0013' just = 'C' )
    ( fieldname = 'BPID' ref_table = 'ZC103MMT0013' just = 'C' )
    ( fieldname = 'BPNAME' ref_table = 'ZC103MMT0002' coltext = '벤더명' emphasize = abap_true )
    ( fieldname = 'RECEIVE_DATE' ref_table = 'ZC103MMT0013' coltext = '납품일' just = 'C' )
    ( fieldname = 'TOTAL_PRICE' ref_table = 'ZC103MMT0013' cfieldname = 'CURRENCY' just = 'R'
                      coltext = '총 금액' emphasize = abap_true )
    ( fieldname = 'CURRENCY' ref_table = 'ZC103MMT0013' coltext = '통화' just = 'C' )
    ( fieldname = 'STATUS_TEXT' coltext = '송장상태' emphasize = abap_true  )
    ( fieldname = 'DOCUMENT_ISSUED' ref_table = 'ZC103MMT0013' coltext = '전표발행여부' just = 'C' )
    ( fieldname = 'CHECKER' just = 'C' coltext = '검증자사번'  emphasize = abap_true )
    ( fieldname = 'CHECKER_NAME' just = 'C' coltext = '검증자이름' )
    ( fieldname = 'CHECK' just = 'C' coltext = '검증' )
*    ( fieldname = 'EXCEL' just = 'C' coltext = '파일' hotspot = abap_true )
    ).

ENDFORM.
*&---------------------------------------------------------------------*
*& Form set_gr_layout
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM set_gr_layout .

  DATA : lv_text(64). " 송장 alv 제목 표시용 (구매오더번호 같이 표기)

  IF gs_sel_pohd IS INITIAL.
    lv_text = |송장 (구매오더번호 : 미선택)|.
  ELSE.
    lv_text = |송장 (구매오더번호 : { gs_sel_pohd-poid })|.
  ENDIF.

  " 레이아웃 세팅
  gs_gr_layo = VALUE #( zebra = abap_true cwidth_opt = 'A' sel_mode = 'D' stylefname = 'CELL_TAB'
                        grid_title = lv_text ).

  " variant 세팅
  gs_gr_vari = VALUE #( report = sy-repid handle = 'ALV2' ).

ENDFORM.
*&---------------------------------------------------------------------*
*& Form handle_hotspot_click
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*&      --> E_ROW_ID
*&      --> SENDER
*&---------------------------------------------------------------------*
FORM handle_hotspot_click  USING    pv_row_id TYPE lvc_s_row
                                    pv_column_id TYPE lvc_s_col
                                    po_sender TYPE REF TO cl_gui_alv_grid.

  CASE po_sender.
    WHEN go_po_grid.
      PERFORM handle_po_hotspot_click USING pv_row_id.
    WHEN go_gr_grid.
      PERFORM handle_gr_hotspot_click USING pv_row_id pv_column_id.
  ENDCASE.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form handle_gr_hotspot_click
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*&      --> PV_ROW_ID
*&---------------------------------------------------------------------*
FORM handle_po_hotspot_click  USING    pv_row_id TYPE lvc_s_row.
  " 구매오더 alv에서 구매오더 번호를 클릭하면 송장 alv가  select 되고 refresh 된다

  DATA : lv_cnt TYPE i.

  " 선택된 구매오더 헤더 가져오기
  CLEAR : gs_pohd, gt_grhd, gv_checker, gv_checker_dptcode, gv_checker_name.
  READ TABLE gt_pohd INTO gs_sel_pohd INDEX pv_row_id-index.

  CASE gs_sel_pohd-order_status.
    WHEN 'A' OR 'B'. " 아직 자재 수령 처리가 되지 않았다면 오류메시지 출력 후 서브루틴 종료
      MESSAGE s032 WITH TEXT-t03 DISPLAY LIKE 'E'.
      EXIT.
    WHEN 'C'. " 자재 수령 문서가 입력된 상황에서는 송장업로드 가능하도록 함
      gv_checkgr_mode = 'E'.
    WHEN OTHERS. " 송장이 이미 입력된 상황이라면 송장업르도 불가능하도록 힘
      gv_checkgr_mode = 'V'.
  ENDCASE.

  " 선택된 구매오더 헤더의 구매오더 번호로 송장 alv 데이터 세팅
  SELECT grid poid bpid receive_date total_price currency gr_status
         document_issued checker belnr gjahr tax_amount
    INTO CORRESPONDING FIELDS OF TABLE gt_grhdback
    FROM zc103mmt0013
   WHERE poid EQ gs_sel_pohd-poid.

  gt_grhd = CORRESPONDING #( gt_grhdback ).
  lv_cnt = lines( gt_grhd ).


  PERFORM set_grhd_data.

  PERFORM refresh_layout USING go_gr_grid.
  PERFORM refresh_grid USING go_gr_grid.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form rece_user_command
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*&      --> PV_UCOMM
*&---------------------------------------------------------------------*
FORM rece_user_command  USING    pv_ucomm.

  CASE pv_ucomm.
    WHEN 'RECE'. " 입고
      PERFORM save_rece_data.
  ENDCASE.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form gr_user_command
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*&      --> PV_UCOMM
*&---------------------------------------------------------------------*
FORM gr_user_command  USING    pv_ucomm.

  CASE pv_ucomm.
    WHEN 'GRUP'.
      PERFORM gr_excel_upload.
    WHEN 'GRDT'.
      PERFORM delete_gr.
    WHEN 'GRSV'.
      PERFORM save_delete_gr.
    WHEN 'FDWN'.
      PERFORM form_download.
    WHEN 'MAIL'.
      PERFORM send_mail.
  ENDCASE.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form gr_excel_upload
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM gr_excel_upload .

  " 엑셀파일을 업로드 하는 함수
  DATA : lt_excel_raw  TYPE TABLE OF alsmex_tabline,   " 엑셀 원본 데이터
         ls_excel_raw  TYPE alsmex_tabline,      " 엑셀 원본 데이터 개별 행
         lt_excel_item TYPE TABLE OF zc103mmt0014,     " 송장 아이템 데이터 테이블
         ls_excel_item TYPE zc103mmt0014,              " 송장 아이템 데이터 개별 행
         ls_excel_head TYPE zc103mmt0013,              " 송장 헤더 데이터
         lv_file       TYPE rlgrap-filename,           " 업로드 파일 명
         lv_value      TYPE string,                    " 개별 셀 값
         lv_grid       TYPE zc103mmt0013-grid,         " 송장 번호
         lv_date(10),    " 납품일
         lv_tabix      TYPE sy-tabix, " 루프 내 인덱스
         external      TYPE bapicurr-bapicurr.

  DATA : lv_tax TYPE price.

  CHECK gs_sel_pohd IS NOT INITIAL.

**********************************************************************
* 엑셀 파일 업로드
**********************************************************************

  " 파일 선택 창 띄우기
  CALL FUNCTION 'F4_FILENAME'
    IMPORTING
      file_name = lv_file.

  IF sy-subrc NE 0.
    MESSAGE s036 DISPLAY LIKE 'E'.
    EXIT.
  ENDIF.

  CHECK lv_file IS NOT INITIAL.

  " 선택된 파일을 읽어오기
  CALL FUNCTION 'ALSM_EXCEL_TO_INTERNAL_TABLE'
    EXPORTING
      filename    = lv_file
      i_begin_col = 1
      i_begin_row = 7
      i_end_col   = 8
      i_end_row   = 1000
    TABLES
      intern      = lt_excel_raw.

  " 파일이 정상적으로 열리지 않거나 관련 없는 엑셀 파일을 입력한 경우 서브루틴 종료
  IF sy-subrc NE 0 OR
     lines( lt_excel_raw ) < 4.
    MESSAGE s036 DISPLAY LIKE 'E'.
    EXIT.
  ENDIF.
**********************************************************************
* 송장 헤더 정보 만들기
**********************************************************************
  CALL FUNCTION 'ZC103MMFG0002'
    EXPORTING
      iv_nro_no = '01'
      iv_object = 'ZC103MM04'
      iv_prefix = 'GR'
    IMPORTING
      ev_id     = lv_grid.

  ls_excel_head-grid = lv_grid.
  ls_excel_head-poid = gs_sel_pohd-poid.
  ls_excel_head-currency = 'KRW'.
  ls_excel_head-gr_status = 'A'. " 송장 미검증 상태
  ls_excel_head-document_issued =  'N'.


  DATA: lv_rece_date   TYPE string,
        lv_test_date   TYPE sy-datum,
        lv_test_amount TYPE p DECIMALS 2,
        lv_error_flag  TYPE abap_bool VALUE abap_false.

  " 헤더 정보 읽어와 설정하기
  LOOP AT lt_excel_raw INTO ls_excel_raw WHERE row = 2.
    CASE ls_excel_raw-col.

      WHEN '1'. " 회사명, 회사코드 세팅
        " 회사명 입력값 검증
        IF ls_excel_raw-value IS INITIAL.
          MESSAGE '회사명이 입력되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 회사명 길이 검증 (예: 최대 40자)
        IF strlen( ls_excel_raw-value ) > 40.
          MESSAGE '회사명이 너무 깁니다. (최대 40자)' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 벤더 테이블에서 회사 검색
        READ TABLE gt_vend INTO gs_vend WITH KEY name = ls_excel_raw-value.
        IF sy-subrc <> 0.
          MESSAGE '등록되지 않은 회사입니다: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " BPID 유효성 검증
        IF gs_vend-bpid IS INITIAL.
          MESSAGE '회사 코드(BPID)가 설정되지 않았습니다: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        ls_excel_head-bpid = gs_vend-bpid.

      WHEN '3'. " 금액 필드
        " 빈 값 검증
        IF ls_excel_raw-value IS INITIAL.
          MESSAGE '금액이 입력되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 콤마 제거
        REPLACE ALL OCCURRENCES OF ',' IN ls_excel_raw-value WITH ''.

        " 공백 제거
        CONDENSE ls_excel_raw-value NO-GAPS.

        IF ls_excel_raw-value CO '0123456789.'.
          MESSAGE '금액 필드에 숫자 이외의 값이 포함되어 있습니다: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 숫자 변환 가능 여부 검증
        TRY.
            lv_test_amount = ls_excel_raw-value.
          CATCH cx_sy_conversion_no_number.
            MESSAGE '금액을 숫자로 변환할 수 없습니다: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
            RETURN.
          CATCH cx_sy_arithmetic_overflow.
            MESSAGE '금액이 허용 범위를 초과했습니다: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
            RETURN.
        ENDTRY.

        " 비즈니스 규칙 검증
        IF lv_test_amount <= 0.
          MESSAGE '금액은 0보다 커야 합니다: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        IF lv_test_amount > 999999999999.
          MESSAGE '금액이 최대 허용값을 초과했습니다: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        ls_excel_head-total_price = ls_excel_raw-value.
        external = ls_excel_head-total_price.

        " 통화키 설정
        CALL FUNCTION 'BAPI_CURRENCY_CONV_TO_INTERNAL'
          EXPORTING
            currency             = 'KRW'
            amount_external      = external
            max_number_of_digits = 15
          IMPORTING
            amount_internal      = external
          EXCEPTIONS
            currency_not_found   = 1
            too_many_digits      = 2
            OTHERS               = 3.

        IF sy-subrc <> 0.
          CASE sy-subrc.
            WHEN 1.
              MESSAGE '통화 KRW를 찾을 수 없습니다.' TYPE 'S' DISPLAY LIKE 'E'.
            WHEN 2.
              MESSAGE '금액 자릿수가 너무 많습니다.' TYPE 'S' DISPLAY LIKE 'E'.
            WHEN OTHERS.
              MESSAGE '통화 변환 중 오류가 발생했습니다.' TYPE 'S' DISPLAY LIKE 'E'.
          ENDCASE.
          RETURN.
        ENDIF.

        ls_excel_head-total_price = external.

      WHEN '4'. " 통화 코드
        " 통화 코드 입력값 검증
        IF ls_excel_raw-value IS INITIAL.
          MESSAGE '통화 코드가 입력되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 통화 코드 길이 검증 (일반적으로 3자리)
        IF strlen( ls_excel_raw-value ) <> 3.
          MESSAGE '통화 코드는 3자리여야 합니다: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 통화 코드 유효성 검증 (테이블 TCURC 체크)
        SELECT SINGLE waers FROM tcurc INTO @DATA(lv_currency_check)
          WHERE waers = @ls_excel_raw-value.

        IF sy-subrc <> 0.
          MESSAGE '유효하지 않은 통화 코드입니다: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        ls_excel_head-currency = ls_excel_raw-value.

      WHEN '5'. " 입고일 세팅
        " 날짜 입력값 검증
        IF ls_excel_raw-value IS INITIAL.
          MESSAGE '입고일이 입력되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        lv_rece_date = ls_excel_raw-value.

        " 점(.) 제거
        REPLACE ALL OCCURRENCES OF '.' IN lv_rece_date WITH ''.
        " 슬래시(/) 제거 (필요시)
        REPLACE ALL OCCURRENCES OF '/' IN lv_rece_date WITH ''.
        " 대시(-) 제거 (필요시)
        REPLACE ALL OCCURRENCES OF '-' IN lv_rece_date WITH ''.

        " 숫자만 포함되는지 검증
        IF lv_rece_date CN '0123456789'.
          MESSAGE '날짜 형식이 올바르지 않습니다 (숫자만 입력): ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 날짜 길이 검증 (YYYYMMDD = 8자리)
        IF strlen( lv_rece_date ) <> 8.
          MESSAGE '날짜는 8자리(YYYYMMDD) 형식이어야 합니다: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 날짜 유효성 검증
        TRY.
            lv_test_date = lv_rece_date.

            " 날짜 형식 추가 검증
            CALL FUNCTION 'DATE_CHECK_PLAUSIBILITY'
              EXPORTING
                date                      = lv_test_date
              EXCEPTIONS
                plausibility_check_failed = 1
                OTHERS                    = 2.

            IF sy-subrc <> 0.
              MESSAGE '유효하지 않은 날짜입니다: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
              RETURN.
            ENDIF.

          CATCH cx_sy_conversion_no_date.
            MESSAGE '날짜 형식이 올바르지 않습니다: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
            RETURN.
        ENDTRY.

        ls_excel_head-receive_date = lv_rece_date.

    ENDCASE.
  ENDLOOP.

  " 최종 필수 필드 검증
  IF ls_excel_head-bpid IS INITIAL.
    MESSAGE '회사 정보가 설정되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  IF ls_excel_head-total_price IS INITIAL.
    MESSAGE '금액 정보가 설정되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  IF ls_excel_head-currency IS INITIAL.
    MESSAGE '통화 정보가 설정되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  IF ls_excel_head-receive_date IS INITIAL.
    MESSAGE '입고일 정보가 설정되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
    RETURN.
  ENDIF.

  " 헤더 타임스탬프 세팅
  lv_tax = ls_excel_head-total_price / 10.
  ls_excel_head = VALUE #( BASE ls_excel_head
                                tax_amount = lv_tax gjahr = sy-datum(4)
                                erdat = sy-datum erzet = sy-uzeit ernam = sy-uname ).

**********************************************************************
* 송장 아이템 정보 만들기
**********************************************************************
  " 엑셀 시트의 4번째 줄 부터 아이템 목록이다
  CLEAR : ls_excel_item, lv_test_amount.

  DATA: lv_test_quantity   TYPE p DECIMALS 3,
        lv_item_error_flag TYPE abap_bool VALUE abap_false,
        lv_check_empty     TYPE abap_bool VALUE abap_false,
        lv_row TYPE i,
        lv_cnt TYPE i VALUE 1,
        ls_excel_raw_check TYPE alsmex_tabline.

  CLEAR : ls_excel_item.

  LOOP AT lt_excel_raw INTO ls_excel_raw WHERE row GE 4.

    lv_tabix = sy-tabix.
    lv_row = ls_excel_raw-row.

    IF lv_row EQ 5.

      CLEAR : ls_excel_raw_check.

    ENDIF.

    IF lv_check_empty EQ abap_false.

      " 빈 값 조회
      DO 7 TIMES.

        CLEAR : ls_excel_raw_check.
        READ TABLE lt_excel_raw INTO ls_excel_raw_check WITH KEY row = lv_row
                                                                       col = sy-index.
        IF sy-subrc EQ 0.

          lv_cnt += 1.

        ENDIF.

      ENDDO.

      IF lv_cnt NE 7.

        MESSAGE |필수값이 없는 컬럼이 존재합니다.| TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.

      ENDIF.

      lv_check_empty = abap_true.

    ENDIF.

    CASE ls_excel_raw-col.

      WHEN '1'. " 자재번호
        " 자재번호 입력값 검증
        IF ls_excel_raw-value IS INITIAL.
          MESSAGE '자재번호가 입력되지 않았습니다.'  TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 자재 마스터에서 존재 여부 확인
        READ TABLE gt_mara INTO gs_mara WITH KEY matid = ls_excel_raw-value.
        IF sy-subrc <> 0.
          MESSAGE '등록되지 않은 자재번호입니다.' && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        ls_excel_item-matid = ls_excel_raw-value.

      WHEN '4'. " 자재수량
        " 수량 입력값 검증
        IF ls_excel_raw-value IS INITIAL.
          MESSAGE '자재수량이 입력되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        lv_value = ls_excel_raw-value.
        " 콤마 제거
        REPLACE ALL OCCURRENCES OF ',' IN lv_value WITH ''.
        " 공백 제거
        CONDENSE lv_value NO-GAPS.

        " 숫자 형식 검증 (양수만, 소수점 허용)
        IF NOT lv_value CO '0123456789.'.
          MESSAGE '수량 필드에 숫자 이외의 값이 포함되어 있습니다.' && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 숫자 변환 가능 여부 검증
        TRY.
            lv_test_quantity = lv_value.
          CATCH cx_sy_conversion_no_number.
            MESSAGE '수량을 숫자로 변환할 수 없습니다.' && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
            RETURN.
          CATCH cx_sy_arithmetic_overflow.
            MESSAGE '수량이 허용 범위를 초과했습니다. ' && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
            RETURN.
        ENDTRY.

        " 비즈니스 규칙 검증
        IF lv_test_quantity <= 0.
          MESSAGE '수량은 0보다 커야 합니다. ' && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        IF lv_test_quantity > 99999.
          MESSAGE '수량이 최대 허용값을 초과했습니다.'  && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        ls_excel_item-quantity = lv_value.

      WHEN '6'. " 개당 단가
        " 단가 입력값 검증
        IF ls_excel_raw-value IS INITIAL.
          MESSAGE '개당 단가가 입력되지 않았습니다.'  TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        lv_value = ls_excel_raw-value.
        " 콤마 제거
        REPLACE ALL OCCURRENCES OF ',' IN lv_value WITH ''.
        " 공백 제거
        CONDENSE lv_value NO-GAPS.

        " 숫자 형식 검증 (양수만, 소수점 허용)
        IF NOT lv_value CO '0123456789'.
          MESSAGE '단가 필드에 숫자 이외의 값이 포함되어 있습니다.'  && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 숫자 변환 가능 여부 검증
        TRY.
            lv_test_amount = lv_value.
          CATCH cx_sy_conversion_no_number.
            MESSAGE '단가를 숫자로 변환할 수 없습니다.' && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
            RETURN.
          CATCH cx_sy_arithmetic_overflow.
            MESSAGE '단가가 허용 범위를 초과했습니다.' && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
            RETURN.
        ENDTRY.

        " 비즈니스 규칙 검증
        IF lv_test_amount <= 0.
          MESSAGE '단가는 0보다 커야 합니다.'  && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        IF lv_test_amount > 999999999999.
          MESSAGE '단가가 최대 허용값을 초과했습니다.'  && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        ls_excel_item-unit_price = lv_value.
        external = ls_excel_item-unit_price.

        " 통화키 설정
        CALL FUNCTION 'BAPI_CURRENCY_CONV_TO_INTERNAL'
          EXPORTING
            currency             = 'KRW'
            amount_external      = external
            max_number_of_digits = 15
          IMPORTING
            amount_internal      = external
          EXCEPTIONS
            currency_not_found   = 1
            too_many_digits      = 2
            OTHERS               = 3.

        IF sy-subrc <> 0.
          CASE sy-subrc.
            WHEN 1.
              MESSAGE '통화 KRW를 찾을 수 없습니다. ' TYPE 'S' DISPLAY LIKE 'E'.
            WHEN 2.
              MESSAGE '단가 자릿수가 너무 많습니다.' TYPE 'S' DISPLAY LIKE 'E'.
            WHEN OTHERS.
              MESSAGE '단가 통화 변환 중 오류가 발생했습니다.' TYPE 'S' DISPLAY LIKE 'E'.
          ENDCASE.
          RETURN.
        ENDIF.

        ls_excel_item-unit_price = external.

      WHEN '7'. " 자재 총 가격
        " 총 가격 입력값 검증
        IF ls_excel_raw-value IS INITIAL.
          MESSAGE '자재 총 가격이 입력되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        lv_value = ls_excel_raw-value.
        " 콤마 제거
        REPLACE ALL OCCURRENCES OF ',' IN lv_value WITH ''.
        " 공백 제거
        CONDENSE lv_value NO-GAPS.

        " 숫자 형식 검증 (양수만)
        IF NOT lv_value CO '0123456789'.
          MESSAGE '총 가격 필드에 숫자 이외의 값이 포함되어 있습니다.' && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 숫자 변환 가능 여부 검증
        TRY.
            lv_test_amount = lv_value.
          CATCH cx_sy_conversion_no_number.
            MESSAGE '총 가격을 숫자로 변환할 수 없습니다.' && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
            RETURN.
          CATCH cx_sy_arithmetic_overflow.
            MESSAGE '총 가격이 허용 범위를 초과했습니다.' && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
            RETURN.
        ENDTRY.

        " 비즈니스 규칙 검증
        IF lv_test_amount <= 0.
          MESSAGE '총 가격은 0보다 커야 합니다.' && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        IF lv_test_amount > 999999999999.
          MESSAGE '총 가격이 최대 허용값을 초과했습니다.' && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        ls_excel_item-total_price = lv_value.
        external = ls_excel_item-total_price.

        " 통화키 설정
        CALL FUNCTION 'BAPI_CURRENCY_CONV_TO_INTERNAL'
          EXPORTING
            currency             = 'KRW'
            amount_external      = external
            max_number_of_digits = 15
          IMPORTING
            amount_internal      = external
          EXCEPTIONS
            currency_not_found   = 1
            too_many_digits      = 2
            OTHERS               = 3.

        IF sy-subrc <> 0.
          CASE sy-subrc.
            WHEN 1.
              MESSAGE '통화 KRW를 찾을 수 없습니다.' TYPE 'S' DISPLAY LIKE 'E'.
            WHEN 2.
              MESSAGE '총 가격 자릿수가 너무 많습니다.' TYPE 'S' DISPLAY LIKE 'E'.
            WHEN OTHERS.
              MESSAGE '총 가격 통화 변환 중 오류가 발생했습니다.' TYPE 'S' DISPLAY LIKE 'E'.
          ENDCASE.
          RETURN.
        ENDIF.

        ls_excel_item-total_price = external.

      WHEN '8'. " 통화
        " 통화 코드 입력값 검증
        IF ls_excel_raw-value IS INITIAL.
          MESSAGE '통화 코드가 입력되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 통화 코드 길이 검증 (3자리)
        IF strlen( ls_excel_raw-value ) <> 3.
          MESSAGE '통화 코드는 3자리여야 합니다.' && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        " 통화 코드 유효성 검증 (테이블 TCURC 체크)
        CLEAR : lv_currency_check.
        SELECT SINGLE waers FROM tcurc INTO @lv_currency_check
          WHERE waers = @ls_excel_raw-value.

        IF sy-subrc <> 0.
          MESSAGE '유효하지 않은 통화 코드입니다.' && ', 값: ' && ls_excel_raw-value TYPE 'S' DISPLAY LIKE 'E'.
          RETURN.
        ENDIF.

        ls_excel_item-currency = ls_excel_raw-value.

      WHEN OTHERS.
    ENDCASE.

    " 7번째 인덱스마다 워크에어리어를 초기화하고 인터널테이블에 값을 넣는다
    " 헤더까지 18개의 행이 사용되었으므로 제외한다
    IF ( lv_tabix - 26 ) MOD 7 EQ 0.

      lv_check_empty = abap_false.
      lv_cnt = 1.

      " 아이템 완성 전 최종 검증
      " 필수 필드 체크
      IF ls_excel_item-matid IS INITIAL.
        MESSAGE '자재번호가 설정되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.

      IF ls_excel_item-quantity IS INITIAL.
        MESSAGE '수량이 설정되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.

      IF ls_excel_item-unit_price IS INITIAL.
        MESSAGE '단가가 설정되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.

      IF ls_excel_item-total_price IS INITIAL.
        MESSAGE '총 가격이 설정되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.

      IF ls_excel_item-currency IS INITIAL.
        MESSAGE '통화가 설정되지 않았습니다.' TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.

      " 계산 검증 (수량 × 단가 = 총 가격)
      DATA: lv_calculated_total TYPE p DECIMALS 2.
      lv_calculated_total = ls_excel_item-quantity * ls_excel_item-unit_price.

      " 꼐산값 검증
      IF abs( lv_calculated_total - ls_excel_item-total_price ) > 0.
        MESSAGE '계산 오류: 수량×단가 ≠ 총가격.' &&
                ', 계산값: ' && lv_calculated_total &&
                ', 입력값: ' && ls_excel_item-total_price TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.

      ls_excel_item-grid = lv_grid.

      " 자재 단위 세팅
      READ TABLE gt_mara INTO gs_mara WITH KEY matid = ls_excel_item-matid.
      IF sy-subrc = 0.
        ls_excel_item-unit = gs_mara-base_unit.
      ELSE.
        MESSAGE '자재 마스터 정보를 찾을 수 없습니다: ' && ls_excel_item-matid TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.

      " 기본 단위 유효성 체크
      IF ls_excel_item-unit IS INITIAL.
        MESSAGE '자재의 기본 단위가 설정되지 않았습니다: ' && ls_excel_item-matid TYPE 'S' DISPLAY LIKE 'E'.
        RETURN.
      ENDIF.

      APPEND ls_excel_item TO lt_excel_item.
      CLEAR ls_excel_item.
    ENDIF.

  ENDLOOP.

**********************************************************************
* 읽은 엑셀 파일을 팝업으로 출력
**********************************************************************
  CLEAR : gs_sel_gr, gt_sel_item_gr, gs_sel_item_gr.
  gs_sel_gr = CORRESPONDING #( ls_excel_head ).
  gt_sel_item_gr = CORRESPONDING #( lt_excel_item ).

  PERFORM set_gr_item_data.


  CALL SCREEN 120 STARTING AT 10 10.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form refresh_layout
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*&      --> GO_GR_GRID
*&---------------------------------------------------------------------*
FORM refresh_layout  USING    po_alv_grid TYPE REF TO cl_gui_alv_grid.

  DATA : lv_text(64). " 타이틀 설정용

  IF gs_sel_pohd IS INITIAL.
    lv_text = |송장 (구매오더번호 : 미선택)|.
  ELSE.
    CHECK gs_sel_pohd-order_status NE 'B'.
    lv_text = |송장 (구매오더번호 : { gs_sel_pohd-poid })|.
  ENDIF.

  CASE po_alv_grid.
    WHEN go_gr_grid.
      gs_gr_layo = VALUE #( BASE gs_gr_layo
                                 grid_title = lv_text ).
      po_alv_grid->set_frontend_layout( EXPORTING is_layout = gs_gr_layo ).
  ENDCASE.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form display_gr_detail
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM display_gr_detail .

  IF go_gr_item_cont IS NOT BOUND.

    CLEAR : gt_sel_item_gr_fcat.
    PERFORM set_gr_item_fcat.
    PERFORM set_gr_item_layo.

    " 오브젝트 생성
    CREATE OBJECT go_gr_item_cont
      EXPORTING
        container_name = 'GR_DETAIL_CONT'.

    CREATE OBJECT go_gr_item_grid
      EXPORTING
        i_parent = go_gr_item_cont.

    " alv 출력
    CALL METHOD go_gr_item_grid->set_table_for_first_display
      EXPORTING
        is_variant           = gs_sel_item_gr_vari
        i_save               = 'A'
        i_default            = 'X'
        is_layout            = gs_sel_item_gr_layo
        it_toolbar_excluding = gt_ui_functions
      CHANGING
        it_outtab            = gt_sel_item_gr
        it_fieldcatalog      = gt_sel_item_gr_fcat.

  ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form set_gr_item_fcat
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM set_gr_item_fcat .

  gt_sel_item_gr_fcat = VALUE #(
    ( key = abap_true fieldname = 'GRID'  ref_table = 'ZC103MMT0014' )
                    ( fieldname = 'MATID' ref_table = 'ZC103MMT0014' )
                    ( fieldname = 'MATNAME' ref_table = 'ZC103MMT0001' coltext = '자재명' emphasize = abap_true  )
                    ( fieldname = 'QUANTITY' ref_table = 'ZC103MMT0014' qfieldname = 'UNIT' coltext = '수량' )
                    ( fieldname = 'UNIT' ref_table = 'ZC103MMT0014' coltext = '단위' just = 'C'  )
                    ( fieldname = 'UNIT_PRICE' ref_table = 'ZC103MMT0014' cfieldname = 'CURRENCY' coltext = '단위 금액' just = 'R' )
                    ( fieldname = 'TOTAL_PRICE' ref_table = 'ZC103MMT0014' cfieldname = 'CURRENCY' coltext = '총 금액'  just = 'R')
                    ( fieldname = 'CURRENCY' ref_table = 'ZC103MMT0014' cfieldname = 'CURRENCY'  coltext = '통화' just = 'C' ) ).

ENDFORM.
*&---------------------------------------------------------------------*
*& Form set_gr_item_layo
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM set_gr_item_layo .

  gs_sel_item_gr_layo = VALUE #( zebra = abap_true cwidth_opt = 'A' ).
  gs_sel_item_gr_vari = VALUE #( report = sy-repid handle = 'ALV5' ).

ENDFORM.
*&---------------------------------------------------------------------*
*& Form set_gr_item_data
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM set_gr_item_data .

  DATA : lv_tabix TYPE sy-tabix.

  " 송장 아이템 세팅
  LOOP AT gt_sel_item_gr INTO gs_sel_item_gr.

    lv_tabix = sy-tabix.

    READ TABLE gt_mara INTO gs_mara WITH KEY matid = gs_sel_item_gr-matid.
    gs_sel_item_gr-matname = gs_mara-matname.
    MODIFY gt_sel_item_gr FROM gs_sel_item_gr INDEX lv_tabix TRANSPORTING matname.

  ENDLOOP.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form save_invoice
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM save_invoice .

  " 송장을 저장하는 서브루탄

**********************************************************************
* 등록
**********************************************************************

  " 저장용 변수 선언
  DATA : ls_grhd  TYPE zc103mmt0013, " 송장헤더
         lt_grit  TYPE TABLE OF zc103mmt0014, " 송장아이템테이블
         ls_grit  TYPE zc103mmt0014, " 송장아이템wa
         ls_row   TYPE lvc_s_row,    " 구매오더인덱스 저장용
         lv_tabix TYPE sy-tabix,
         lv_tax   TYPE zc103e_mm_taxamount.

  " 송장헤더
  ls_grhd = CORRESPONDING #( gs_sel_gr ). "  선택된 송장을 저장

  lv_tax = ls_grhd-total_price / 10. " 총 부가가치세 계산

  " 회계년도, 부가가치세, 수정 타임스탬프 세팅
  ls_grhd = VALUE #( BASE ls_grhd
                     gjahr = sy-datum(4) tax_amount = lv_tax
                     erdat = sy-datum erzet = sy-uzeit ernam = sy-uname ).

  " 송장아이템
  lt_grit = CORRESPONDING #( gt_sel_item_gr ).
  " 아이템 타임스탬프 세팅
  LOOP AT lt_grit INTO ls_grit.

    lv_tabix = sy-tabix.

    ls_grit = VALUE #( BASE ls_grit
                       erdat = sy-datum erzet =  sy-uzeit ernam = sy-uname ).

    MODIFY lt_grit FROM ls_grit INDEX lv_tabix TRANSPORTING erdat erzet ernam.

  ENDLOOP.

  " 데이터 저장
  MODIFY zc103mmt0013 FROM ls_grhd.
  MODIFY zc103mmt0014 FROM TABLE lt_grit.

  " 정상적으로 저장 가능하면 저장, 아니면 롤백
  IF sy-subrc EQ 0.
    COMMIT WORK.
    MESSAGE s022.
  ELSE.
    ROLLBACK WORK.
    MESSAGE s023 DISPLAY LIKE 'E'.
  ENDIF.

  " 구매오더 alv, 송장 alv 새로고침
  " 입력 기준에 따라 구매오더 데이터를 새로 가져온다 (노드 더블클릭 이벤트 로직과 같음)
  PERFORM get_base_data.

  CASE gv_subscreen.
    WHEN '0101'.
      PERFORM handle_on_node_double_click USING gv_sel_node_key go_receipt_tree.
      PERFORM count_num.
    WHEN '0102'.
      PERFORM handle_on_node_double_click USING gv_sel_node_key go_stlo_tree.
      PERFORM count_stlo_num.
  ENDCASE.

  " 송장 데이터를 새로 가지고온다.
  READ TABLE gt_pohd WITH KEY poid = gs_sel_pohd-poid TRANSPORTING NO FIELDS. " 인덱스만 확인
  ls_row-index = sy-tabix.
  PERFORM handle_po_hotspot_click USING ls_row.

  PERFORM refresh_grid USING : go_po_grid, go_gr_grid.

  " 완료 후 창 닫기

  CALL METHOD : go_gr_item_grid->free, go_gr_item_cont->free.

  FREE : go_gr_item_grid, go_gr_item_cont.

  LEAVE TO SCREEN 0.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form set_grhd_data
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM set_grhd_data .
  " 송장 데이터 텍스트 데이터 세팅

  DATA : lt_dd07v TYPE TABLE OF dd07v,
         ls_dd07v TYPE dd07v,
         lv_tabix TYPE sy-tabix.

  CALL FUNCTION 'GET_DOMAIN_VALUES'
    EXPORTING
      domname    = 'ZC103D_MM_GRSTATUS'
      text       = abap_true
    TABLES
      values_tab = lt_dd07v.

  LOOP AT gt_grhd INTO gs_grhd.

    CLEAR : ls_dd07v, gs_vend, gs_emp.

    " 상태 텍스트값 세팅
    lv_tabix = sy-tabix.
    READ TABLE lt_dd07v INTO ls_dd07v WITH KEY domvalue_l = gs_grhd-gr_status.
    gs_grhd-status_text = ls_dd07v-ddtext.

    " 상태 아이콘, 셀 버튼 세팅
    CASE gs_grhd-gr_status.
      WHEN 'A'.
        gs_grhd-status = icon_led_yellow.
        gs_grhd-check  = '검증하기'.
        " 버튼 세팅
        gs_grhd-cell_tab = VALUE #( ( fieldname = 'CHECK' style = cl_gui_alv_grid=>mc_style_button ) ).
      WHEN 'B'.
        gs_grhd-status = icon_led_green.
        gs_grhd-check  = '검증완료'.
    ENDCASE.

    " 검증자 정보 세팅
    READ TABLE gt_emp INTO gs_emp WITH KEY empno = gs_grhd-checker.
    gs_grhd-checker_name = gs_emp-empname.

    " 벤더명 세팅
    READ TABLE gt_vend INTO gs_vend WITH KEY bpid = gs_grhd-bpid.
    gs_grhd-bpname = gs_vend-name.

    " 엑셀 아이콘 세팅
    gs_grhd-excel = icon_xls.

    MODIFY gt_grhd FROM gs_grhd INDEX lv_tabix TRANSPORTING status_text bpname status checker_name
                                                            check cell_tab excel.

  ENDLOOP.

ENDFORM.
*&---------------------------------------------------------------------*
*& Form handle_gr_cell_btn_click
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*&      --> PS_COL_ID
*&      --> PS_ROW_NO
*&---------------------------------------------------------------------*
FORM handle_gr_cell_btn_click  USING ps_col_id TYPE lvc_s_col
                                     ps_row_no TYPE lvc_s_roid.

  " 송장검증을 진행하는 버튼 로직 처리
  " 검증용 데이터를 가져오고 수량, 금액이 모두 같은지 확인하여 상태를 세팅한다


  DATA : lt_checkgr LIKE TABLE OF gs_checkgr,     " 검증 팝업창 itab
         lt_invoice TYPE TABLE OF zc103mmt0015,   " 송장
         ls_invoice TYPE zc103mmt0015,            " 송장
         lt_poit    TYPE TABLE OF zc103mmt0012,   " 구매오더아이템
         ls_poit    TYPE zc103mmt0012,            " 구매오더아이템
         lv_tabix   TYPE sy-tabix.

  " 데이터 가져오기
  READ TABLE gt_grhd INTO gs_grhd INDEX ps_row_no-row_id.

  " 송장
  SELECT a~grid poid matid quantity AS gr_quantity unit AS gr_unit
         a~total_price AS gr_price a~currency AS gr_currency
    INTO CORRESPONDING FIELDS OF TABLE gt_checkgr
    FROM zc103mmt0014 AS a
   INNER JOIN zc103mmt0013 AS b
      ON a~grid EQ b~grid
   WHERE a~grid EQ gs_grhd-grid.

  " 자재 수령
  SELECT ivid poid quantity unit price currency matid
    INTO CORRESPONDING FIELDS OF TABLE lt_invoice
    FROM zc103mmt0015
   WHERE poid EQ gs_grhd-poid.

  " 구매오더
  SELECT poid quantity unit price currency matid
    INTO CORRESPONDING FIELDS OF TABLE lt_poit
    FROM zc103mmt0012
   WHERE poid EQ gs_grhd-poid.

  " 송장아이템
  SELECT grid matid quantity unit
    INTO CORRESPONDING FIELDS OF TABLE gt_sel_item_gr
    FROM zc103mmt0014
   WHERE grid EQ gs_grhd-grid.

  " 상태, 자재이름 세팅
  LOOP AT gt_checkgr INTO gs_checkgr.

    lv_tabix = sy-tabix.

    " 자재수령값 세팅
    CLEAR : ls_invoice, ls_poit.
    READ TABLE lt_invoice INTO ls_invoice WITH KEY poid = gs_checkgr-poid
                                                   matid = gs_checkgr-matid.
    " 구매오더값 세팅
    READ TABLE lt_poit INTO ls_poit WITH KEY poid = gs_checkgr-poid
                                             matid = gs_checkgr-matid.

    gs_checkgr = VALUE #( BASE gs_checkgr
                          ivid = ls_invoice-ivid
                          iv_quantity = ls_invoice-quantity iv_unit = ls_invoice-unit
                          iv_price = ls_invoice-price iv_currency = ls_invoice-currency
                          po_quantity = ls_poit-quantity po_unit = ls_poit-unit
                          po_price = ls_poit-price po_currency = ls_poit-currency ).

    " 정상 상태
    IF ( gs_checkgr-gr_price EQ gs_checkgr-po_price ) AND
       ( gs_checkgr-po_price EQ gs_checkgr-iv_price ) AND
       ( gs_checkgr-gr_quantity EQ gs_checkgr-po_quantity ) AND
       ( gs_checkgr-po_quantity EQ gs_checkgr-iv_quantity ).
      gs_checkgr-status = icon_led_green.
      " 수량만 안맞는 상태
    ELSEIF ( gs_checkgr-gr_price    IS NOT INITIAL AND
             gs_checkgr-po_price    IS NOT INITIAL AND
             gs_checkgr-iv_price    IS NOT INITIAL AND
             gs_checkgr-gr_quantity IS NOT INITIAL AND
             gs_checkgr-po_quantity IS NOT INITIAL AND
             gs_checkgr-iv_quantity IS NOT INITIAL ).

      " 세 문서에 자재가 모두 있고, 금액 또는 수량만 안 맞는 경우
      gs_checkgr-status = icon_led_yellow.

    ELSE.
      gs_checkgr-status = icon_led_red.
    ENDIF.

    READ TABLE gt_mara INTO gs_mara WITH KEY matid = gs_checkgr-matid.
    gs_checkgr-matname = gs_mara-matname.

    MODIFY gt_checkgr FROM gs_checkgr INDEX lv_tabix TRANSPORTING status matname ivid iv_quantity
      iv_unit iv_price iv_currency po_quantity po_unit po_price po_currency.

  ENDLOOP.

  CALL SCREEN 130 STARTING AT 10 10. " 송장 검증 팝업창

ENDFORM.

----------------------------------------------------------------------------------
Extracted by Direct Download Enterprise version 1.3.1 - E.G.Mellodew. 1998-2005 UK. Sap Release 758
```
